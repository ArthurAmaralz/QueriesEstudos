/* POSTGRES SQL - INICIO*/

/* SEMPRE QUE FOR TRABALHAR COM DADOS VERIFICAR O FORMADO DA DATA NO BANCO DE DADOS, ATRAVES DO ``DATESTYLE`` E ALTERAR CASO NECESSARIO */

SELECT SEXO, COUNT(*) AS "QUANTIDADE" FROM FUNCIONARIOS GROUP BY SEXO;

SELECT DEPARTAMENTO, COUNT(*) AS "QUANTIDADE" FROM FUNCIONARIOS GROUP BY DEPARTAMENTO;

selecT MAX(SALARIO) FROM FUNCIONARIOS;
SELECT MIN(SALARIO) FROM funcionarios;
SELECT AVG(SALARIO) FROM FUNCIONARIOS; --TRUNCARTE COMO ??

--MAXIMO E MINIMO NA MESMA LINHA
selecT MAX(SALARIO) AS "MAIOR SALARIO",MIN(SALARIO) AS "MENOR SALARIO" FROM FUNCIONARIOS;

-- POR DEPARTAMENTO
selecT DEPARTAMENTO, MAX(SALARIO) AS "MAIOR SALARIO",MIN(SALARIO) AS "MENOR SALARIO" 
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO;

/* AGRUPANDO O DEPARTAMENTOS, O VALOR DE TODOS SALARIOS, A MEDIA E EM ORDEM DECRECENTE */

SELECT departamento, SUM(SALARIO) AS "SOMA SALARIAL", ROUND(AVG(SALARIO),2) AS "MEDIA"
--ROUND ARREDONDA O VALOR PAA '2' CASAS DECIMAIS, PODENDO NAO PASSAR PARAMETRO
FROM funcionarios
GROUP BY DEPARTAMENTO
ORDER BY 3 DESC;
-- 3 REPRESENTA A TERCEIRA COLUNAR(A MEDIA),DESC PARA FICAR EM ORDEM DECRECENTE

-- AULA 124 EXCEL --

CREATE TABLE MAQUINAS(
	MAQUINA VARCHAR(20),
	DIA INT,
	QTD NUMERIC(10,2)
);

COPY MAQUINAS
FROM 'Z:\Módulo Postgres\LogMaquinas.csv'
--VERIFICAR AS PERMISSOES DA PASTA PARA TRANFERIR
DELIMITER ','
CSV HEADER;

SELECT * FROM MAQUINAS;

SELECT MAQUINA, ROUND(AVG(QTD)2) AS MEDIA_QTD
FROM MAQUINAS
GROUP BY MAQUINA
ORDER BY 2;

--MODA

SELECT MAQUINA, QTD, COUNT(*) AS MODA
FROM MAQUINAS
GROUP BY MAQUINA, QTD
ORDER BY  3;

-- A MODA E MAIS COMPLEXA PARA APRESENTAR, POIS PODE SER 'MULTIMODAL' OU SEJA, TER N MODAS. UMA FORMAR E APRESENTAR DESSA FORMA PARA SIMPLIFICAR

SELECT MAQUINA, QTD, COUNT(*) FROM MAQUINAS
WHERE MAQUINA = 'Maquina 01'
GROUP BY MAQUINA, QTD
ORDER BY 3 DESC
LIMIT 1;
--O LIMIT VAI SER OPCIONAL

/* moda do dataset inteiro */

SELECT  QTD, COUNT(*) AS MODA
FROM MAQUINAS
GROUP BY QTD
ORDER BY 2 DESC;

/* AMPLITUDE */
SELECT MAQUINA, MAX(QTD) AS "MAXIMO",
				MIN(QTD) AS "MINIMO",
				MAX(QTD) - MIN(QTD) AS "AMPLITUDE"
FROM MAQUINAS
GROUP BY maquina
ORDER BY 4 DESC;

/* DESVIO PADRAO E VARIANCIA */

STDDEV_POP(coluna) -- DESVIO PADRAO
VAR_POP(coluna) --VARIANCIA

SELECT MAQUINA,
	   ROUND(AVG(QTD),2) AS MEDIA,
	   MAX(QTD) AS MAXIMO,
	   MIN(QTD) AS MINIMO,
	   MAX(QTD) - MIN(QTD) AS AMPLITUDE,
	   ROUND(STDDEV_POP(QTD),2) AS DESV_PAD,
	   ROUND(VAR_POP(QTD),2) AS VARIANCIA
	   FROM MAQUINAS
	   GROUP BY MAQUINA
	   ORDER BY 4 DESC;   
	   
	   
	   /* FUNCAO MEDIANA */
	   
	   
CREATE OR REPLACE FUNCTION _final_median(NUMERIC[])
   RETURNS NUMERIC AS
$$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$$
LANGUAGE 'sql' IMMUTABLE;


										 
CREATE AGGREGATE median(NUMERIC) (
  SFUNC=array_append,
  STYPE=NUMERIC[],
  FINALFUNC=_final_median,
  INITCOND='{}'
);

/* FUNCAO E ANALISE DA MEDIANA NO ARQUIVO 02 - Funcao de Mediana.sql */


SELECT  MAQUINA,
		COUNT(QTD) AS "QUANTIDADE",
		SUM(QTD) AS "SOMA",
		ROUND(AVG(QTD),2) AS "MEDIA",
		MAX(QTD) AS "MAXIMO",
		MIN(QTD) AS "MINIMO",
		MAX(QTD) - MIN(QTD) AS "AMPLITUDE",
		ROUND(STDDEV_POP(QTD),2) AS DESV_PAD,
	    ROUND(VAR_POP(QTD),2) AS VARIANCIA,
		ROUND(MEDIAN(QTD),2) AS MEDIANA,
		ROUND((STDDEV_POP(QTD) / AVG(QTD)) * 100,2) AS "COEF. VARIACAO"
FROM MAQUINAS
GROUP BY MAQUINA
ORDER BY 1;

/* MODA - MODE() WITHIN GROUP(ORDER BY COLUNA)  */

SELECT * FROM MAQUINAS;

SELECT MODE() WITHIN GROUP(ORDER BY QTD) AS "MODA" FROM MAQUINAS;

SELECT MAQUINA, MODE() WITHIN GROUP(ORDER BY QTD) AS "MODA" 
FROM MAQUINAS
GROUP BY MAQUINA;

SELECT MAQUINA,
	   COUNT(QTD) AS "QUANTIDADE",
	   SUM(QTD) AS "TOTAL",
	   ROUND(AVG(QTD),2) AS "MEDIA",
	   MAX(QTD) AS "MAXIMO",
	   MIN(QTD) AS "MINIMO",
	   MAX(QTD) - MIN(QTD) AS "AMPLIT. TOTAL",
	   ROUND(VAR_POP(QTD),2) AS "VARIANCIA",
	   ROUND(STDDEV_POP(QTD),2) AS "DESV. PADRAO",
	   ROUND(MEDIAN(QTD),2) AS "MEDIANA",
	   ROUND((STDDEV_POP(QTD) / AVG(QTD)) * 100,2) AS "COEF. VARIACAO",
	   MODE() WITHIN GROUP(ORDER BY QTD) AS "MODA"
FROM MAQUINAS
GROUP BY MAQUINA
ORDER BY 1;

/* create table as select */

/*Podemos criar uma tabela com o resultado de uma querie
e essa é a forma de realizar uma modelagem colunar 
CREATE TABLE AS SELECT
*/


CREATE TABLE GENERO(
	IDGENERO INT PRIMARY KEY,
	NOME VARCHAR(30)
);

INSERT INTO GENERO VALUES(1,'FANTASIA');
INSERT INTO GENERO VALUES(2,'AVENTURA');
INSERT INTO GENERO VALUES(3,'SUSPENSE');
INSERT INTO GENERO VALUES(4,'AÇÃO');
INSERT INTO GENERO VALUES(5,'DRAMA');

CREATE TABLE FILME(
	IDFILME INT PRIMARY KEY,
	NOME VARCHAR(50),
	ANO INT,
    ID_GENERO INT,
	FOREIGN KEY(ID_GENERO)
	REFERENCES GENERO(IDGENERO)
);

INSERT INTO FILME VALUES(100,'KILL BILL I',2007,2);
INSERT INTO FILME VALUES(200,'DRACULA',1998,3);
INSERT INTO FILME VALUES(300,'SENHOR DOS ANEIS',2008,1);
INSERT INTO FILME VALUES(400,'UM SONHO DE LIBERDADE',2008,5);
INSERT INTO FILME VALUES(500,'OS BAD BOYS',2008,4);
INSERT INTO FILME VALUES(600,'GUERRA CIVIL',2016,2);
INSERT INTO FILME VALUES(700,'CADILLAC RECORDS',2009,5);
INSERT INTO FILME VALUES(800,'O HOBBIT',2008,1);
INSERT INTO FILME VALUES(900,'TOMATES VERDES FRITOS',2008,5);
INSERT INTO FILME VALUES(1000,'CORRIDA MORTAL',2008,4);

CREATE TABLE LOCACAO(
	IDLOCACAO INT PRIMARY KEY,
	DATA DATE,
	MIDIA INT,
	DIAS INT,
	ID_FILME INT,
	FOREIGN KEY(ID_FILME)
	REFERENCES FILME(IDFILME)

);

select * from locacao

INSERT INTO LOCACAO VALUES(1,'01/08/2019',23,3,100);
INSERT INTO LOCACAO VALUES(2,'01/02/2019',56,1,400);
INSERT INTO LOCACAO VALUES(3,'02/07/2019',23,3,400);
INSERT INTO LOCACAO VALUES(4,'02/02/2019',43,1,500);
INSERT INTO LOCACAO VALUES(5,'02/02/2019',23,2,100);
INSERT INTO LOCACAO VALUES(6,'03/07/2019',76,3,700);
INSERT INTO LOCACAO VALUES(7,'03/02/2019',45,1,700);
INSERT INTO LOCACAO VALUES(8,'04/08/2019',89,3,100);
INSERT INTO LOCACAO VALUES(9,'04/02/2019',23,3,800);
INSERT INTO LOCACAO VALUES(10,'05/07/2019',23,3,500);
INSERT INTO LOCACAO VALUES(11,'05/02/2019',38,3,800);
INSERT INTO LOCACAO VALUES(12,'01/10/2019',56,1,100);
INSERT INTO LOCACAO VALUES(13,'06/12/2019',23,3,400);
INSERT INTO LOCACAO VALUES(14,'01/02/2019',56,2,300);
INSERT INTO LOCACAO VALUES(15,'04/10/2019',76,3,300);
INSERT INTO LOCACAO VALUES(16,'01/09/2019',32,2,400);
INSERT INTO LOCACAO VALUES(17,'08/02/2019',89,3,100);
INSERT INTO LOCACAO VALUES(18,'01/02/2019',23,1,200);
INSERT INTO LOCACAO VALUES(19,'08/09/2019',45,3,300);
INSERT INTO LOCACAO VALUES(20,'01/12/2019',89,1,400);
INSERT INTO LOCACAO VALUES(21,'09/07/2019',23,3,1000);
INSERT INTO LOCACAO VALUES(22,'01/12/2019',21,3,1000);
INSERT INTO LOCACAO VALUES(23,'01/02/2019',34,2,100);
INSERT INTO LOCACAO VALUES(24,'09/08/2019',67,1,1000);
INSERT INTO LOCACAO VALUES(25,'01/02/2019',76,3,1000);
INSERT INTO LOCACAO VALUES(26,'01/02/2019',66,3,200);
INSERT INTO LOCACAO VALUES(27,'09/12/2019',90,1,400);
INSERT INTO LOCACAO VALUES(28,'03/02/2019',23,3,100);
INSERT INTO LOCACAO VALUES(29,'01/12/2019',65,5,1000);
INSERT INTO LOCACAO VALUES(30,'03/08/2019',43,1,1000);
INSERT INTO LOCACAO VALUES(31,'01/02/2019',27,31,200);


-- SELECT DAS COLUNAS CRIADAS 

SELECT F.NOME AS "FILME", G.NOME AS "GENERO", L.DATA, L.MIDIA, L.DIAS
FROM filme F
INNER JOIN genero G
ON G.IDGENERO = F.id_genero
INNER JOIN locacao L
ON F.IDFILME = L.ID_FILME;

-- PARA CRIAR UMA TABELA COM AS QUERY, USAMOS O 'CREATE TABLE AS SELECT...'

CREATE TABLE REL_LOCADORA AS SELECT F.NOME AS "FILME", G.NOME AS "GENERO", L.DATA, L.MIDIA, L.DIAS
FROM filme F
INNER JOIN genero G
ON G.IDGENERO = F.id_genero
INNER JOIN locacao L
ON F.IDFILME = L.ID_FILME;

/* SALVANDO O ARQUIVO DE CONSULTA DO BANCO*/


-- 'TO' PARA EXPORTAR E 'FROM' PARA IMPORTAR
COPY rel_locadora TO
--SEMPRE COLOCAR O FORMATO DO ARQUIVO
'C:\REL_LOCADORA.CSV'
DELIMITER ';'
CSV HEADER; 


/* SINCRONIZANDO TABELAS E RELATORIOS */

DROP TABLE LOCACAO;

CREATE TABLE LOCACAO(
	IDLOCACAO INT PRIMARY KEY,
	DATA TIMESTAMP,
	MIDIA INT,
	DIAS INT,
	ID_FILME INT,
	FOREIGN KEY(ID_FILME)
	REFERENCES FILME(IDFILME)

);
/* PODERIA SER SERIAL TBM PARA O AUTO INCREMENTO */
CREATE SEQUENCE SEQ_LOCACAO;
--VAI INSERIR O ID NAS TABELAS
NEXTVAL('SEQ_LOCACAO');

INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/08/2018',23,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',56,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/07/2018',23,3,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/02/2018',43,1,500);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/02/2018',23,2,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/07/2018',76,3,700);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/02/2018',45,1,700);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/08/2018',89,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/02/2018',23,3,800);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'05/07/2018',23,3,500);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'05/02/2018',38,3,800);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/10/2018',56,1,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'06/12/2018',23,3,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',56,2,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/10/2018',76,3,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/09/2018',32,2,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'08/02/2018',89,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',23,1,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'08/09/2018',45,3,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',89,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/07/2018',23,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',21,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',34,2,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/08/2018',67,1,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',76,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',66,3,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/12/2018',90,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/02/2018',23,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',65,5,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/08/2018',43,1,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',27,31,200);

SELECT * FROM LOCACAO;	
SELECT * FROM GENERO;
SELECT * FROM FILME;
SELECT * FROM REL_LOCADORA;

DROP TABE REL_LOCADORA;

SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO G
INNER JOIN FILME F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO L
ON L.ID_FILME = F.IDFILME;

CREATE TABLE RELATORIO_LOCADORA AS 
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO G
INNER JOIN FILME F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO L
ON L.ID_FILME = F.IDFILME;

SELECT * FROM RELATORIO_LOCADORA;
SELECT * FROM LOCACAO;

/* SELECT PARA TRAZER OS REGISTROS NOVOS */

SELECT MAX(IDLOCACAO) AS RELATORIO, 
/* UM SELECT DE OUTRA TABELA SEM JOIN */
--IMPORTANTE ANALISAR --
(SELECT MAX(IDLOCACAO) FROM LOCACAO) AS LOCACAO
FROM RELATORIO_LOCADORA;
					
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO G
INNER JOIN FILME F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO L
ON L.ID_FILME = F.IDFILME
/* O WHERE IRA TRAZER OS NOVOS VALORES QUE FORAM INSERIDOS NA TABALA LOCACAO E NAO ESTAO NA RELATORIO */
WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM RELATORIO_LOCADORA);

/* SCRIPT PARA INSERIR OS REGISTROS NOVOS ,
ISSO E O QUE SERA USADO PARA FUNCAO */

INSERT INTO RELATORIO_LOCADORA
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO G
INNER JOIN FILME F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO L
ON L.ID_FILME = F.IDFILME
WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM RELATORIO_LOCADORA);

/* VAMOS DEIXAR ESSE PROCEDIMENTO AUTOMATICO POR MEIO
DE UMA TRIGGER */

--NO POSTGRESS PRECISAMOS CRIAR UMA FUNCAO COM TODO BLOCO DE PROGRAMACAO E DEPOIS CRIAMOS A TRIGGER Q CHAMARA ESSA FUNCAO
CREATE OR REPLACE FUNCTION ATUALIZA_REL()
RETURNS TRIGGER AS $$
BEGIN
--INSERE OS DADOS DA TABELA QUE NAO ESTA CONTIDA NA OUTRA
	INSERT INTO RELATORIO_LOCADORA
	SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
	FROM GENERO G
	INNER JOIN FILME F
	ON G.IDGENERO = F.ID_GENERO
	INNER JOIN LOCACAO L
	ON L.ID_FILME = F.IDFILME
	WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM RELATORIO_LOCADORA);
--CRIA O ARQUIVO E EXPORTA
	COPY RELATORIO_LOCADORA TO
	--NAO ESQUECER DE CRIAR O DIRETORIOS
	'C:\RELATORIO_LOCADORA.CSV'
	DELIMITER ';'
	CSV HEADER;

RETURN NEW;
END;
$$
-- APENAS INFORMA A LINGUAGEM SENDO USADA QUE E DO PROPRIO BANCO
LANGUAGE PLPGSQL;	

/* COMANDO PARA APAGAR UMA TRIGGER */

DROP TRIGGER TG_RELATORIO ON LOCACAO;

/* CRIANDO A TRIGER */

CREATE TRIGGER TG_RELATORIO
AFTER INSERT ON LOCACAO
FOR EACH ROW
	EXECUTE PROCEDURE ATUALIZA_REL();
	
/* INSERINDO NOVOS REGISTROS */

INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),100,7,300);

INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),500,1,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),800,6,500);



/* SINCRONIZANDO COM REGISTROS DELETADOS */

CREATE OR REPLACE FUNCTION DELETE_LOCACAO()
RETURNS TRIGGER AS
$$
BEGIN
-- OS ARQUIVOS DEETADOS SEMPRE SERAO OLD. NO INCIO
DELETE FROM RELATORIO_LOCADORA
WHERE IDLOCACAO = OLD.IDLOCACAO;

COPY RELATORIO_LOCADORA TO
'C:\RELATORIO_LOCADORA.CSV'
DELIMITER ';'
CSV HEADER;

RETURN OLD;
END;
$$
LANGUAGE PLPGSQL;

CREATE TRIGGER DELETE_REG
	BEFORE DELETE ON LOCACAO 
	FOR EACH ROW
	EXECUTE PROCEDURE DELETE_LOCACAO();

SELECT * FROM LOCACAO;	

SELECT * FROM RELATORIO_LOCADORA;	

DELETE FROM LOCACAO 
WHERE IDLOCACAO = 1;

--------------------------------
/* EXERCICIO */
--------------------------------

--MODA DOS SALARIOS

SELECT SALARIO, COUNT(SALARIO) AS "MODA"
FROM FUNCIONARIOS
GROUP BY SALARIO
--GROUP BY NAO FUNCIONA COM WHERE, USAMOS HAVING NO LUGAR
HAVING COUNT(SALARIO) > 1
ORDER BY 1 DESC;

--MODA PASSADA NO CURSO
SELECT MODE() WITHIN GROUP(ORDER BY SALARIO) AS "MODA" 
FROM FUNCIONARIOS;

-- MODA DEPARTAMENTAL = DEPARTAMENTO Q MAIS EMPREGA
-- R. BELEZA E ROUPA

SELECT DEPARTAMENTO, COUNT(NOME) AS "MODA"
FROM funcionarios
GROUP BY DEPARTAMENTO
ORDER BY 2 DESC;

SELECT MODE() WITHIN GROUP(ORDER BY DEPARTAMENTO) AS "MODA" 
FROM FUNCIONARIOS;

--DESVIO PADRAO

SELECT ROUND(STDDEV_POP(DEPARTAMENTO),2) AS "DESV. PADRAO"
FROM FUNCIONARIOS;

SELECT DEPARTAMENTO,CARGO, COUNT(DISTINCT CARGO) AS "DESV. PADRAO"
FROM FUNCIONARIOS
GROUP BY 3
ORDER BY 3 DESC;


/* QUERY PARA PEGAR VALORES UNICOS */
SELECT CARGO AS "CARGOS UNICOS"
FROM FUNCIONARIOS
GROUP BY 1
HAVING COUNT(DISTINCT CARGO) = 1;


--AMPLITUDE DOS SALARIOS

SELECT (MAX(SALARIO) - MIN(SALARIO)) AS AMPLITUDE
FROM FUNCIONARIOS;

--MEDIANA

SELECT DEPARTAMENTO, CARGO, ROUND(MEDIAN(SALARIO),2) AS "MEDIANA"
FROM FUNCIONARIOS
GROUP BY 1,2
ORDER BY 3 DESC;

--CRIANDO COLUNAS DUMMY

SELECT NOME, CARGO FROM FUNCIONARIOS;

SELECT NOME, CARGO,--COMO E UMA OUTRA COLUNA COLOCAR ,
CASE
	-- VALORES COM ASPAS SIMPLES
	WHEN CARGO = 'Structural Engineer' THEN 'CONDICAO 01'
	WHEN CARGO = 'Financial Advisor' THEN 'CONDICAO 02'
	WHEN CARGO = 'Recruiting Manager' THEN 'CONDICAO 03'
	WHEN CARGO = 'Desktop Support Technician' THEN 'CONDICAO 04'
	ELSE 'OUTRAS CONDICOES'
END AS CONDICOES
FROM FUNCIONARIOS;
		
		
SELECT NOME,
CASE
	-- O WHEN VAI SER CASE SENSITIVE
	WHEN SEXO = 'Masculino' THEN 'M'
	ELSE 'F'
END AS "SEXO"
FROM FUNCIONARIOS;

/* RETORNAR BOLEANO NA COLUNA */

SELECT NOME, CARGO, (SEXO = 'Masculino') AS MASCULINO,
--O INVERSO TBM E VALIDO
(SEXO = 'Feminino') AS FEMININO
FROM FUNCIONARIOS;


--OS OIS CASES DENTRO DE UMA QUERY
SELECT NOME, CARGO, 
--PRIMRA COLUNA PARA MASCULINO
CASE
	WHEN (SEXO = 'Masculino')= TRUE THEN 1
	ELSE 0
END AS "Masculino",
--SEGUNDA PARA FEMININO 
CASE
	WHEN (SEXO = 'Feminino')= TRUE THEN 1
	ELSE 0
END AS "Feminino"
FROM FUNCIONARIOS;

/* 140 - AULA DE FILTROS */

-- FILTRO BASEADO EM VALORES NUMERICOS

SELECT NOME, DEPARTAMENTO
FROM FUNCIONARIOS
--PERCEBE QUE NAO SOU OBRIGADO A PROJETAR O SALARIO NAS COLUNAS
WHERE SALARIO > 100000;

--FILTRO COM STRINGS

SELECT NOME, DEPARTAMENTO, SALARIO
FROM FUNCIONARIOS
WHERE DEPARTAMENTO = 'Ferramentas';

--AGREGADOR BASEADO EM CARACTERES

SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
WHERE DEPARTAMENTO LIKE 'B%'
GROUP BY DEPARTAMENTO;

SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
--NESSE CASO ELE COMECA COM B E TERMINA EM S
WHERE DEPARTAMENTO LIKE 'B%s'
GROUP BY DEPARTAMENTO;

--HAVING SEMPRE USADO PARA COLUNAS AGREGADAS

SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
WHERE DEPARTAMENTO LIKE 'B%s'
GROUP BY DEPARTAMENTO
HAVING SUM(SALARIO) > 400000;


/* FILTROS AGREGADORES */

--PUXANDO OS VALORES COM DOIS SELECTS, MAS ISSO DEGRADA A PERFORMACE DO BANCO
SELECT COUNT(*) AS TOTAL,
(SELECT COUNT(*) FROM FUNCIONARIOS WHERE SEXO LIKE 'M%') AS MASCULINO
FROM FUNCIONARIOS;


--MANEIRA CORRETA COM >> FILTER <<
SELECT COUNT(*) AS TOTAL,
COUNT(*) FILTER( WHERE SEXO LIKE 'M%') AS MASCULINO,
COUNT(*) FILTER( WHERE DEPARTAMENTO = 'Books') AS LIVROS,
COUNT(*) FILTER( WHERE SALARIO > 140000) AS "SALARIO > 140K"
FROM FUNCIONARIOS;

/* FORMATANDO STRINGS */

--VALORES DISTINTOS / UNICOS
SELECT DISTINCT DEPARTAMENTO
FROM FUNCIONARIOS;

--TUDO MAIUSCULO OU MINUSCULO
SELECT DISTINCT UPPER(DEPARTAMENTO)
FROM FUNCIONARIOS;

SELECT DISTINCT LOWER(DEPARTAMENTO)
FROM FUNCIONARIOS;

--CONTATENAR COLUNAS || NO LUGAR DO +
SELECT CARGO || ' - ' || DEPARTAMENTO
FROM FUNCIONARIOS;

--PODENDO SER USADO COM OUTRAS FUNCOES
SELECT DISTINCT CARGO || ' - ' || DEPARTAMENTO
FROM FUNCIONARIOS;


/* CRIAR UMA COLUNA AO LADO DE CARGO E DIZER SE A PESSOA E ASSISTINTE OU NAO */

--SE ATENTAR NO CASE SENSITIVE
SELECT CARGO, CARGO LIKE '%Assistant%' AS "ASSISTENTE?"
FROM FUNCIONARIOS;

SELECT DEPARTAMENTO, CARGO,
CASE 
	WHEN CARGO LIKE '%Assistant%' THEN 'SIM'
	ELSE 'NAO'
END AS "ASSISTENTE?"
FROM FUNCIONARIOS;

--OU DESSA FORMAR TBM
SELECT DEPARTAMENTO, CARGO,
CASE 
	WHEN (CARGO LIKE '%Assistant%') = TRUE THEN 1
	ELSE 0
END AS "ASSISTENTE?"
FROM FUNCIONARIOS;

