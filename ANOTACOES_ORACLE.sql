/* ANOTACOES ORACLE */

--segmentos sao objetos do banco e considerados logicos.
--exemplo: VIEWS, INDICES, TABELAS, PROCEDURES, FUNCOES
--EXTENT SAO CONJUNTOS DE SEGMENTOS

--sennha oracle linux user root senha 123456
--mobaxtreme olokojk123

--SHOW USER;
--senha win >> system / 1234

--SEMPRE QUE FIZER UMA TRIGGER DE DELETE, USAR BEFORE PARA EVITAR ERROS

/* NO ORACLE SEMPRE QUE PRECISAR FAZER UM SELECT A NAO EXITIR TABELA, USAR A DUAL*/

--RETORNA UM ERRO
SELECT 1+1;

--MANEIRA IDEAL
SELECT 1+1 AS SOMA FROM DUAL;

--OLHAR OS DICIONARIOS
SELECT * FROM DICT;

--OLHAR A INSTANCIA, EU ESTOU USANDO PARALELISMO??
-->>> V$ <<< REPRESENTA UMA VIEWER
SELECT PARALLEL FROM V$INSTANCE;

--NOME DO BANCO 
SELECT NAME FROM V$DATABASE;

--VERSAO DO BANCO
SELECT BANNER FROM V$VERSION;

--VERIFICAR PRIVILEGIOS
SELECT * FROM USER_SYS_PRIVS;

--VERIFICAR TODAS TABELAS
SELECT TABLE_NAME FROM USER_TABLES;


/* CRIANDO A TABELA NO ORACLE */

CREATE TABLE CURSOS(
	IDCURSO INT PRIMARY KEY,
	NOME VARCHAR2(30),
	CARGA INT
-- PARA DESTINAR A TABELA PARA USERS	
)TABLESPACE USERS;

CREATE TABLE TEST(
	IDTEST INT,
	NOME VARCHAR2(30)
--SEM DESTINAR VAI PARA TABLE DO USUARIO LOGADO	
);

/* DICIONARIO DE DADOS */

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'CURSOS';

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'TEST';

--QUANDO ESTA LOGADO NO USUARIO 'SYSTEM' O OBJETO E CRIADO NA TABLE SPACE SYSTEM. QUANDO O USUARIO NAO E SYSTEM ELE VAI PARA USERS POR PADAO



--TRAZENDO ALGUNS DADOS
SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME, BYTES, BLOCKS, EXTENTS 
FROM USER_SEGMENTS
WHERE SEGMENT_NAME = 'CURSOS';



/* CRIANDO UMA TABLESPACE */

CREATE TABLESPACE RH
DATAFILE 'C:\DATA\RH_01.DBF'
SIZE 10M AUTOEXTEND --TAMANHO INICIAL E QUE CONTINUA CRESCENDO
ON NEXT 10M --AUMENTANDO DE..
MAXSIZE 50M; --CAPACIDADE MAXIMA

--DESSA FORMAR CRIAMOS UM SEGUNDO ARQUIVO DE ARMAZENAMENTO DA TABLESPACE, SO QUE AGORA NAO SABEMOS QUAL DAS DUAS OS DADOS FISICOS SERAM ARMAZENADOS
ALTER TABLESPACE RH  --ALTERANDO EM VEZ DE CRIAR
ADD DATAFILE 'C:\DATA\RH_02.DBF' --ARQUIVO AGORA E 02
SIZE 10M AUTOEXTEND
ON NEXT 10M
MAXSIZE 50M;


-- CONFERIR AS TABLESPACES
SELECT TABLESPACE_NAME, FILE_NAME FROM DBA_DATA_FILES;


--NO ORACLE O AUTOINCREMENT FUNCIONA COM SEQUENCE

CREATE SEQUENCE SEQ_GERAL
START WITH 10
INCREMENT BY 5;


CREATE TABLE FUNCIONARIOS(
	IDFUNCIONARIO INT PRIMARY KEY,
	NOME VARCHAR2(30) --IR DIRETO NO VARCHAR 2
)TABLESPACE RH;


INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'ARTHUR');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'LAIS');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL,'CLARA');

SELECT IDFUNCIONARIO, NOME FROM FUNCIONARIOS;

/* CRIANDO TS MARKETING */

CREATE TABLESPACE MARKETING
DATAFILE 'C:\DATA\MKT_01.DBF'
SIZE 10M AUTOEXTEND 
ON NEXT 10M 
MAXSIZE 50M;

CREATE TABLE CAMPANHA(
	IDCAMPANHA INT PRIMARY KEY,
	NOME VARCHAR2(30) 
)TABLESPACE MARKETING;

INSERT INTO CAMPANHA VALUES(SEQ_GERAL.NEXTVAL,'VERAO');
INSERT INTO CAMPANHA VALUES(SEQ_GERAL.NEXTVAL,'PRIMAVERA');
INSERT INTO CAMPANHA VALUES(SEQ_GERAL.NEXTVAL,'INVERNO');

/* PARA MIGRAR OS DADOS DO BANCO DE UM DIRETORIO PARA OUTRO, PRECISAMOS DEIXALOS OFFLINE */

ALTER TABLESPACE RH OFFLINE;

--DEPOIS DE OFF, FAZER A TRANSFERENCIAS DO ARQUIVO PARA O LOCAL DESTINO

ALTER TABLESPACE RH
RENAME DATAFILE 'C:\DATA\RH_01.DBF' TO 'C:\PRODUCAO\RH_01.DBF';

ALTER TABLESPACE RH
RENAME DATAFILE 'C:\DATA\RH_02.DBF' TO 'C:\PRODUCAO\RH_02.DBF';

ALTER TABLESPACE RH ONLINE;


--CRIANDO NOVAS TABELAS

CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY,
	NOME VARCHAR2(30),
	EMAIL VARCHAR2(30),
	MENSALIDADE NUMERIC(10,2)
);

--PODERIA CRIAR OUTRA SEQUENCE PARA SUPORTAR OS IDS
INSERT INTO ALUNO VALUES(SEQ_GERAL.NEXTVAL,'ARTHUR','BKABLABLA',1000);
INSERT INTO ALUNO VALUES(SEQ_GERAL.NEXTVAL,'LAIS','LALALA',2000);
INSERT INTO ALUNO VALUES(SEQ_GERAL.NEXTVAL,'CLARA','CLACLA', 500);

/* PSEUDO TABELAS */
--ROWID ROWNUM, USADAS PARA TUNNING E CONSULTAS MAIS AGEIS
SELECT ROWID, ROWNUM, IDALUNO, NOME, MENSALIDADE
FROM ALUNO;


/* TRIGGER */

--TRIGGER PADAO ORACLE
CREATE OR REPLACE PROCEDURE AUMENTO(P_IDALUNO ALUNO.IDALUNO%TYPE,
P_PORCENTAGEM NUMERIC)
--APOS A VARIAVEL,TEMOS QUE DECLARAR O TIPO, MAS PARA O TIPO FICAR DINAMICO COM A TABELA USAMOS NOMETABELA.CAMPOTABELA%TYPE
AS
	BEGIN
		UPDATE ALUNO SET MENSALIDADE = MENSALIDADE * (1 + (P_PORCENTAGEM/100))
		WHERE IDALUNO = P_IDALUNO;
	
	END;
	/
	

CREATE OR REPLACE PROCEDURE AUMENTO(P_IDALUNO ALUNO.IDALUNO%TYPE,
P_PORCENTAGEM NUMERIC)
AS
	BEGIN
		UPDATE ALUNO SET MENSALIDADE = MENSALIDADE * (1 + (P_PORCENTAGEM/100))
		WHERE IDALUNO = P_IDALUNO;
	
	END;
	/
	
--EXECUTANDO PROCEDURE

CALL AUMENTO(120,10);

/* TRIGGERS - DEVEM TER O TAMANHO MAXIMO DE 32KBITS E
NAO DEVEM EXECUTAR COMANDO DE DTL - COMMIT, ROLLBACK, SAVEPOINTS */

--PARA CRIAR OU ATUALIZAR
CREATE OR REPLACE TRIGGER CHECK_AUMENTO
--PODEMOS CONFIGURAR MAIS DE UMA ACAO AO MESMO TEMPO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW
BEGIN
	--NO ORACLE SE USA OS : NA FRENTE DA VARIAVEL NOVA OU VELHA
	IF :NEW.MENSALIDADE < 2000 THEN
	RAISE_APPLICATION_ERROR(-20000,'VALOR A BAIXO DO MINIMO');
	END IF;
END;
/
---INSERT SERA NEGADO POIS O VALOR E MENOR QUE 2K	
INSERT INTO ALUNO VALUES(SEQ_GERAL.NEXTVAL,'MARIA','MCLACLA', 500);

--ULTILIZAR O COMANDO A BAIXO SEMPRE Q TIVER ERROS
SHOW ERRORS;

--CONFERIR AS TRIGGES EXITENTES
SELECT TRIGGER_NAME, TRIGGER_BODY
FROM USER_TRIGGERS;



/* CRIANDO UM EVENTO COM TRIGGERS E PROCEDURES */

--CRIASSE A TABELA DE AUDITORIA
CREATE TABLE AUDITORIA(
	DATA_LOGIN DATE,
	LOGIN VARCHAR2(30)
);

-- CRIASSE A PROCEDURE COM O QUE VAI SER FEITO
CREATE OR REPLACE PROCEDURE LOGPROC IS
BEGIN
	INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN)
	VALUES(SYSDATE,USER);
--LOGPROC NO FINAL NAO OBRIGATORIO
END LOGPROC;
/

--E AGORA CRIAMOS A TRIGGER Q CHAMARA A PROCEDURE

CREATE OR REPLACE TRIGGER LOGTRIGGER
AFTER LOGON ON DATABASE
CALL LOGPROC
/

--ADD UM NOVA COLUNA
ALTER TABLE AUDITORIA
ADD (HORA TIMESTAMP)

--AJUSTANDO NA TRIGGER
CREATE OR REPLACE PROCEDURE LOGPROC IS
BEGIN
	INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN, HORA)
	VALUES(SYSDATE,USER,SYSTIMESTAMP);
END LOGPROC;
/

UPDATE AUDITORIA SET HORA = SYSTIMESTAMP;

--FALHA NO LOGIN
CREATE OR REPLACE TRIGGER FALHA_LOGIN
AFTER SERVERERROR
ON DATABASE
BEGIN
	IF (IS_SERVERERROR(1017)) THEN
	INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN, HORA)
	VALUES(SYSDATE,'ORA-1017',SYSTIMESTAMP);
	END IF;
END;
/

--SEMPRE QUE FIZER UMA TRIGGER DE DELETE, USAR BEFORE PARA EVITAR ERROS

CREATE TABLE USUARIO(
	ID INT,
	NOME VARCHAR2(30)
);

CREATE TABLE BKP_USE(
	ID INT,
	NOME VARCHAR(30)
);

CREATE OR REPLACE TRIGGER TRG_USE
BEFORE DELETE ON USUARIO
--N'AO ESQUECER O FOR EACH ROW!!!!
FOR EACH ROW
BEGIN
-- OLD SEMPRE PARA PEGAR VALORES ANTERIORES NO DELETE
	INSERT INTO BKP_USE VALUES(:OLD.ID,:OLD.NOME);
END;
/

INSERT INTO USUARIO VALUES(1,'ARTHUR');
INSERT INTO USUARIO VALUES(2,'CLARA');
INSERT INTO USUARIO VALUES(3,'LAIS');

-- TRABALHANDO COM VIEWS

---VC PODE ULTILIZAR UMA VIEWS PARA PERMITIMIR A CONSULTA A COLUNAS LIMITADAS E NAO PERMITIR ACESSO A TODAS AS COLUNAS.
--EXEMPLO A TABELA FUNCIONARIOS QUE CONTEM O VALOR SALARIO QUE DEVE SER CONFIDENCIAL, NESSE CASO CRIAMOS UMA VIEW SEM A COLUNA SALARIO
CREATE OR REPLACE VIEW V_USE
AS
	SELECT ID,NOME FROM USUARIO;
	
--TBM E POSSIVEL ACRESCENTAR VALORES PELA VIEWER, A MENOS QUE A VIEW TENHA UM JOIN
INSERT INTO V_USE VALUES(4,'RAQUEL');

SELECT * FROM V_USE;

--PARA IMPEDIR A INSERIR USAMOS O COMANDO WITH READ ONLY
CREATE OR REPLACE VIEW V_USE
AS
	SELECT ID,NOME FROM USUARIO
	WITH READ ONLY;
	
/* CRIANDO UMA VIEW SEM TABELAS EXISTENTES */	
--USAMOS O 'FORCE' PARA ISSO
CREATE OR REPLACE FORCE VIEW V_RELATORIO
AS	
	SELECT NOME, SEXO, NUMERO
	FROM CLIENTE
	INNER JOIN TELEFONE
	ON IDCLIENTE = ID_CLIENTE;

--DESSA FORMA A VIEWE CRIADA, MAS COM ERROS DE COMPILACAO. PARA RESOLVER PRECISAMOS APENAS CRIAR AS TABELAS

CREATE TABLE CLIENTE(
	IDCLIENTE INT,
	NOME VARCHAR2(30),
	SEXO CHAR(1)
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT,
	NUMERO VARCHAR(10),
	ID_CLIENTE INT
);

ALTER TABLE CLIENTE ADD CONSTRAINT PK_CLIENTE
PRIMARY KEY (IDCLIENTE);

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE); --APENAS CLIENTE, SEM A CHAVE SERIA SUFICIENTE NO ORACLE.
	
SELECT * FROM V_RELATORIO;

/* DEIXANDO O BANCO SEM CHECAR AS PK E FK PARA INSERIR */

--OLHANDO AS CONSTRAINTS
SELECT CONSTRAINT_NAME,DEFERRABLE AS ATRASADA, DEFERRED AS VERIFICACAO
FROM USER_CONSTRAINTS WHERE TABLE_NAME IN ('CLIENTE','TELEFONE')
	
--PODEMOS ATRASAR A VERIFICACAO
ALTER TABLE TELEFONE DROP CONSTRAINT FK_CLIENTE_TELEFONE

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE)
DEFERRABLE;

--MESMO ATRASADO AINDA ESTA SENDO VERIFICADO, PARA RETIRAMOS ISSO USAMOS O COMANDO
SET CONSTRAINT ALL DEFERRED; --SO ATRASA AT O PROXIMO COMMIT

--FAZENDO ISSO PERDEMOS TODA A INTEGRIDADE DO BANCO, POIS PERMITE A INSERCAO DE DADOS SEM CONFERIR A REFERENCIA.
--FELIZMENTE APOS FAZER UM COMMIT, TODAS INSERCOES SERAM TESTADAS E DADO ROLLBACK SE APRESENTAREM INCONSISTENCIA...

	








